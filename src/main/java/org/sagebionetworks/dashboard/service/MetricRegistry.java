package org.sagebionetworks.dashboard.service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.joda.time.DateTime;
import org.sagebionetworks.dashboard.dao.NameIdDao;
import org.sagebionetworks.dashboard.metric.TimeSeriesToWrite;
import org.sagebionetworks.dashboard.metric.UniqueCountToWrite;
import org.sagebionetworks.dashboard.model.Aggregation;
import org.sagebionetworks.dashboard.model.MetricType;
import org.sagebionetworks.dashboard.model.Statistic;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service("metricRegistry")
public class MetricRegistry {

    @Autowired
    public MetricRegistry(
            final Collection<TimeSeriesToWrite> tsToWrite,
            final Collection<UniqueCountToWrite> ucToWrite,
            final NameIdDao nameIdDao) {

        this.tsToWrite = Collections.unmodifiableCollection(tsToWrite);
        this.ucToWrite = Collections.unmodifiableCollection(ucToWrite);

        final Map<String, String> nameIdMap = new HashMap<String, String>();
        for (TimeSeriesToWrite mtw : this.tsToWrite) {
            String name = mtw.getName();
            String id = nameIdDao.getId(name);
            nameIdMap.put(name, id);
        }
        for (UniqueCountToWrite mtw : this.ucToWrite) {
            String name = mtw.getName();
            String id = nameIdDao.getId(name);
            nameIdMap.put(name, id);
        }
        this.nameIdMap = Collections.unmodifiableMap(nameIdMap);

        List<MetricToRead> metricsToRead = new ArrayList<MetricToRead>();
        Map<String, MetricToRead> idTypeMetricMap = new HashMap<String, MetricToRead>();

        createMetric(
                "Newly Registered Users",
                "Daily counts of newly registered users.",
                new String[] {"createUserMetric", "changePasswordMetric"},
                MetricType.UNIQUE_COUNT,
                Aggregation.day,
                Statistic.n,
                DateTime.now().minusDays(8),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);

        createMetric(
                "Daily Unique Users",
                "The number of unique users that logged activities on a daily basis.",
                new String[] {"uniqueUserMetric"},
                MetricType.UNIQUE_COUNT,
                Aggregation.day,
                Statistic.n,
                DateTime.now().minusDays(8),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);

        createMetric(
                "Top Users",
                "Users with the most activitities.",
                new String[] {"uniqueUserMetric"},
                MetricType.TOP,
                Aggregation.day,
                Statistic.n,
                DateTime.now().minusDays(1),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);

        createMetric(
                "Top Entities",
                "List of entities that are accessed most often.",
                new String[] {"topEntityMetric"},
                MetricType.TOP,
                Aggregation.day,
                Statistic.n,
                DateTime.now().minusDays(1),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);

        createMetric(
                "Top Clients",
                "List of programming clients sorted in descending order of their activities.",
                new String[] {"topClientMetric"},
                MetricType.TOP,
                Aggregation.day,
                Statistic.n,
                DateTime.now().minusDays(1),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);

        createMetric(
                "GET Entity Bundle Latencies",
                "Latency in milliseconds for the GET entity bundle REST API.",
                new String[] {"getEntityBundleMetric"},
                MetricType.TIME_SERIES,
                Aggregation.hour,
                Statistic.avg,
                DateTime.now().minusDays(3),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);
/*
 * Disable reading the top error counts for now.
 *
        createMetric(
                "Count of Errors by Clients",
                "The number of errors generated by clients.",
                "clientErrorMetric",
                MetricType.TOP,
                Aggregation.day,
                Statistic.n,
                DateTime.now().minusDays(1),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);

        createMetric(
                "Count of Errors by REST APIs",
                "The number of errors generated by calls to REST APIs.",
                "methodErrorMetric",
                MetricType.TOP,
                Aggregation.day,
                Statistic.n,
                DateTime.now().minusDays(1),
                DateTime.now().minusDays(1),
                metricsToRead,
                idTypeMetricMap);
 */

        this.metricsToRead = Collections.unmodifiableList(metricsToRead);
        this.idTypeMetricMap = Collections.unmodifiableMap(idTypeMetricMap);
    }

    public Collection<TimeSeriesToWrite> timeSeriesToWrite() {
        return tsToWrite;
    }

    public Collection<UniqueCountToWrite> uniqueCountToWrite() {
        return ucToWrite;
    }

    public List<MetricToRead> metricsToRead() {
        return metricsToRead;
    }

    public MetricToRead getMetric(String metricId, MetricType type) {
        return idTypeMetricMap.get(metricId + ":" + type);
    }

    private void createMetric(
            final String name,
            final String description,
            final String[] metricToWriteName,
            final MetricType metricType,
            final Aggregation aggregation,
            final Statistic statistic,
            final DateTime defaultStart,
            final DateTime defaultEnd,
            final List<MetricToRead> list,
            final Map<String, MetricToRead> map) {

        MetricToRead mtr = new MetricToRead();
        mtr.setName(name);
        mtr.setDescription(description);
        String id = "";
        for (String mName : metricToWriteName) {
            id = id + nameIdMap.get(mName) + ":";
        }
        id = id.substring(0, id.length() - 1);
        if (id == null) {
            throw new RuntimeException("Incorrect metricToWriteName.");
        }
        mtr.setId(id);
        mtr.setType(metricType);
        mtr.setDefaultAggregation(aggregation);
        mtr.setDefaultStatistic(statistic);
        mtr.setDefaultStart(defaultStart);
        mtr.setDefaultEnd(defaultEnd);

        list.add(mtr);
        map.put(mtr.getId() + ":" + mtr.getType(), mtr);
    }

    private final Collection<TimeSeriesToWrite> tsToWrite;
    private final Collection<UniqueCountToWrite> ucToWrite;
    private final List<MetricToRead> metricsToRead;
    private final Map<String, String> nameIdMap;
    private final Map<String, MetricToRead> idTypeMetricMap;
}
